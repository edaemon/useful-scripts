#!/usr/bin/env bash

# AWS Systems Manager SSH Helper

# A wrapper/helper script that makes it easier to use SSH over
# AWS Systems Manager (SSM).

# This is meant for use in conjuction with SSH config similar to this:
#
#   Host i-* mi-*
#       User ec2-user
#       ProxyCommand bash -c "/path/to/ssmh --login %r:%h:%p"
#       IdentityFile ~/.ssh/aws/id_aws
#       IdentitiesOnly yes
#
# With the above in place, after sourcing this script you can run an SSH command to connect
# to any of the listed EC2 instances, e.g.:
#
#   ssh i-018e5463bz49918e6

display_usage() {
  echo "Usage: . $(basename ${BASH_SOURCE[0]}) [OPTION]..."
  echo ""
  echo "Switch AWS profiles and list instance IDs that are available for SSH logins via AWS SSM"
  echo ""
  echo "Available options:"
  echo "-h, --help                         Display this help message"
  echo "-p, --profile [PROFILE]            AWS CLI profile to switch to; defaults to AWS_PROFILE envvar, or"
  echo "                                     provides a list to choose from"
  echo "-s, --select                       Disregard any profile in AWS_PROFILE and allow selection"
  echo "-l, --login [USER:INSTANCE:PORT]   Generates a session on the specified instance, including copying"
  echo "                                     the SSH public key to it (meant for use with SSH config)"
  echo "-k, --key                          The SSH public key to use for logins, defaults to ~/.ssh/aws/id_aws"
  echo ""
  echo "Note that SSH logins rely on existing SSH configuration. To access an instance,"
  echo "you will need configuration like this in an SSH config file (e.g. ~/.ssh/config):"
  echo ""
  echo "  # SSH via Session Manager"
  echo "  Host i-* mi-*"
  echo "      User ec2-user"
  echo "      ProxyCommand bash -c \"/path/to/ssmh --login %r:%h:%p\""
  echo "      IdentityFile ~/.ssh/aws/id_aws"
  echo "      IdentitiesOnly yes"
  echo ""
  echo "Finally, note that this script must be sourced instead of running it directly!"
  echo "Run it using either 'source $(basename ${BASH_SOURCE[0]})' or '. $(basename ${BASH_SOURCE[0]})'."
  echo "More simply, configure a shell alias, e.g. in ~/.bashrc or ~/.bash_profile:"
  echo ""
  echo "  alias ssmh=\"source /path/to/ssmh\""
  echo ""
}

# Check for AWS CLI
if ! [ -x "$(command -v aws)" ]; then
  echo "Error: the AWS CLI is not installed!" >&2
fi

### Define defaults
OPTIONS=""
LOGIN=false
TARGET=""
PUBLIC_KEY_FILE="${HOME}/.ssh/aws/id_aws.pub"
PROFILE=${AWS_PROFILE}

### Validate arguments
while (( "$#" )); do
  case "$1" in
    -h|--help)
      display_usage
      return
      ;;
    -p|--profile)
      PROFILE=$2
      shift 2
      ;;
    -s|--select)
      PROFILE=''
      shift
      ;;
    -l|--login)
      LOGIN=true
      TARGET=(${2//:/ })
      shift 2
      ;;
    -k|--key)
      PUBLIC_KEY_FILE=$2
      shift
      ;;
    -*|--*=) # Unknown options
      echo "ERROR: Unknown argument: $1" >&2
      ;;
    *) # Preserve positional arguments
      OPTIONS="$OPTIONS $1"
      shift
      ;;
  esac
done

eval set -- "$OPTIONS"

### Ensure this script is being sourced except for logins
if [[ "${BASH_SOURCE[0]}" == "${0}" ]] && [ "${LOGIN}" = false ]; then
  echo ""
  echo "ERROR: $(basename ${BASH_SOURCE[0]}) is not being sourced! Profile switching will not persist!" >&2
  echo "This means that an SSH connection may not use the correct profile, causing it to fail." >&2
  echo "To persist profile changes, run this with either 'source $(basename ${BASH_SOURCE[0]})' or '. $(basename ${BASH_SOURCE[0]})'." >&2
  echo ""
  exit 1
fi

### Handle login mode
if [ "${LOGIN}" = true ]; then
  # Exit on error
  set -e
  # Set up variables
  TARGET_USER=${TARGET[0]}
  TARGET_INSTANCE=${TARGET[1]}
  TARGET_PORT=${TARGET[2]}
  # Copy the SSH public key to the target instance
  echo "Copying public key to target..." &> /dev/tty
  PUBLIC_KEY=$(cat "${PUBLIC_KEY_FILE}")
  COMMAND_ID=$(aws ssm send-command \
    --instance-ids "${TARGET_INSTANCE}" \
    --document-name 'AWS-RunShellScript' \
    --parameters commands="\"
      mkdir -p /home/${TARGET_USER}/.ssh
      grep -F '${PUBLIC_KEY}' /home/${TARGET_USER}/.ssh/authorized_keys || echo '${PUBLIC_KEY}' >> /home/${TARGET_USER}/.ssh/authorized_keys
      chown -R ${TARGET_USER}:${TARGET_USER} /home/${TARGET_USER}/.ssh/
      chmod -R u=rwX,g=,o= /home/${TARGET_USER}/.ssh/
    \"" \
    --query Command.CommandId \
    --output text)
  # Wait for command to complete
  while true; do
    STATUS=$(aws ssm get-command-invocation \
      --command-id "${COMMAND_ID}" \
      --instance-id "${TARGET_INSTANCE}" \
      --query Status \
      --output text)
    if [[ "${STATUS}" != "Success" ]]; then
      sleep 3;
    else
      break
    fi
  done
  echo "Public key is in place on ${TARGET_INSTANCE}" &> /dev/tty
  # Start a session on the target instance
  echo "Starting SSH session..." &> /dev/tty
  aws ssm start-session --target "${TARGET_INSTANCE}" --document-name AWS-StartSSHSession --parameters "portNumber=${TARGET_PORT}"
fi

### Select a profile
if [ -z ${PROFILE} ]; then
  mapfile -t profiles < <(aws configure list-profiles)
  echo "Select a profile:"
  select profile in "${profiles[@]}" "Cancel"; do
    case ${profile} in
      "Cancel")
        echo "Cancelled"
        return
        ;;
      *)
        PROFILE="${profile}"
        break
        ;;
    esac
  done
  echo "Profile set to: ${PROFILE}"
else
  echo "Using profile: ${PROFILE}"
fi

# Set the profile for SSH and CLI commands
export AWS_PROFILE="${PROFILE}"

### Identify instances
# Retrieve the list of SSM-enabled instances
mapfile -t instances < <(aws ssm describe-instance-information --query InstanceInformationList[].InstanceId --output text | tr '\t' ' ')

# Warn of the SSO login requirement
if [ -z "${instances}" ]; then
  echo "No SSM-enabled instances were found! Please verify this in the AWS console." >&2
  echo "This profile may require an SSO login, which you can now run with:" >&2
  echo "  aws sso login" >&2
  return
fi

# Retrieve and display further details on the instances
aws ec2 describe-instances --instance-ids ${instances} --query 'Reservations[*].Instances[*].{Name:Tags[?Key==`aws:autoscaling:groupName`]|[0].Value,Instance:InstanceId,State:State.Name,Hostname:PrivateDnsName}' --output table
